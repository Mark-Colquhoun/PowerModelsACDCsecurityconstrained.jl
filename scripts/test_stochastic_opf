using Pkg
Pkg.activate("./scripts")

using Ipopt
using Cbc
using JuMP
using PolyChaos
using KernelDensity
using PowerModels
using StochasticPowerModels
using PowerModelsACDC
using PowerModelsSecurityConstrained
using PowerModelsACDCsecurityconstrained

nlp_solver = optimizer_with_attributes(Ipopt.Optimizer, "max_cpu_time" => 600.0, "tol" => 1e-6) # "obj_scaling_factor" => 1e0
lp_solver = optimizer_with_attributes(Cbc.Optimizer, "logLevel"=>0)

aux  = true
deg  = 2
case = "./data/case5_spm.m"
data  = PowerModels.parse_file(case)
PowerModelsACDC.process_additional_data!(data)
sdata = PowerModelsACDCsecurityconstrained.build_stochastic_data_GM(data, deg)


# test stochatic ACDC
result_acr = PowerModelsACDCsecurityconstrained.run_sopf_acr_GM(data, PowerModels.ACRPowerModel, nlp_solver, aux=aux, deg=deg)

# test case verification
setting = Dict("output" => Dict("branch_flows" => true), "conv_losses_mp" => true)
result_acdc = PowerModelsACDC.run_acdcopf(data, PowerModels.ACPPowerModel, nlp_solver, setting = setting)
result_acdc_acr = PowerModelsACDCsecurityconstrained.run_acdcopf_acr(data, PowerModels.ACRPowerModel, nlp_solver, setting = setting)



#test original AC grid only
result_acr1 = StochasticPowerModels.run_sopf_acr(data, PowerModels.ACRPowerModel, nlp_solver, aux=aux, deg=deg)


@test result_acr["termination_status"] == LOCALLY_SOLVED
obj1 = result_acr["objective"]

data  = _PM.parse_file(file)
result_acr2 = _SPM.run_sopf_acr(data, _PM.ACRPowerModel, nlp_solver; aux=aux, deg=deg)
@test result_acr2["termination_status"] == LOCALLY_SOLVED
obj2 = result_acr2["objective"]

sdata = _SPM.build_stochastic_data(data, deg)
result_acr3 = _PM.run_model(sdata, _PM.ACRPowerModel, nlp_solver, _SPM.build_sopf_acr_with_aux; multinetwork=true, solution_processors=[_PM.sol_data_model!])